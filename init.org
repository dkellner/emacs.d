#+TITLE: Emacs Configuration
#+AUTHOR: Dominik Kellner
#+PROPERTY: header-args :tangle yes

* Initialization

** Lexical scope

#+begin_src emacs-lisp
;;; init.el --- user-init-file                    -*- lexical-binding: t -*-
;;;
;;; DO NOT EDIT THIS FILE!
;;; This file was automatically generated by tangling `init.org`.
#+end_src

* Package management

I use Nix with the [[https://github.com/nix-community/emacs-overlay][emacs overlay]] to build Emacs including packages directly
from =use-package= declarations in this file. The packages are already added to
=load-path=, so we can disable Emacs' own package manager entirely.

** Disable Emacs' own package manager

#+begin_src emacs-lisp
(require 'package)
(setq package-archives nil
      package-enable-at-startup nil)
#+end_src

*** TODO (Probably) move to =early-init.el= in Emacs 27

** Install packages and add them to the current session's =load-path=

A rebuild of my Emacs Nix expression will not alter the current session's
=load-path=. The functions here are quick and dirty ways to load a package in the
current session, without having to add Nix' store paths to =load-path= manually.

#+begin_src emacs-lisp
(defun dkellner/add-elpa-package-to-load-path (package)
  "Install PACKAGE from ELPA and add Nix' store path to `load-path'.

This does install dependencies but does not (yet) add them to
`load-path'. You need to call this function manually for any
missing dependencies."
  (interactive "sPackage: ")
  (dkellner/add-package-to-load-path
   "nixpkgs.emacsPackages.elpaPackages"
   package))

(defun dkellner/add-melpa-package-to-load-path (package)
  "Install PACKAGE from MELPA and add Nix' store path to `load-path'.

This does install dependencies but does not (yet) add them to
`load-path'. You need to call this function manually for any
missing dependencies."
  (interactive "sPackage: ")
  (dkellner/add-package-to-load-path
   "nixpkgs.emacsPackages.melpaPackages"
   package))

;; TODO: error handling
(defun dkellner/add-package-to-load-path (packageSet package)
  (let* ((nix-expr (format "%s.%s" packageSet package))
         (build-output (shell-command-to-string
                        (format "nix build --no-link %s" nix-expr)))
         (root (shell-command-to-string
                (format "nix eval --raw %s" nix-expr)))
         (dir-regex (format "%s.*" package))
         (path (car (directory-files
                     (concat root "/share/emacs/site-lisp/elpa/")
                     t dir-regex))))
    (add-to-list 'load-path path)))
#+end_src

* Common

These packages and functions are used by various other subsections.

** use-package

#+begin_src emacs-lisp
(require 'use-package)
#+end_src

** no-littering

=no-littering= needs to be loaded as early as possible, see
https://github.com/emacscollective/no-littering#usage for details.

#+begin_src emacs-lisp
(use-package no-littering
  :ensure t)
#+end_src

** diminish

#+begin_src emacs-lisp
(use-package diminish
  :ensure t)
#+end_src

** hydra

#+begin_src emacs-lisp
(use-package hydra
  :ensure t)
#+end_src

** Run commands in an external terminal
#+begin_src emacs-lisp
(defun dkellner/term-command (cmd &rest args)
  (let* ((cmd-with-args (s-join " " (cons cmd args)))
         (name (format "alacritty: %s" cmd-with-args)))
  (apply #'start-process
         name
         (format "*%s*" name)
         "alacritty"
         "--title"
         cmd-with-args
         "--command"
         cmd
         args)))
#+end_src

* Sensible defaults

** A good starting point: `better-defaults`

From https://github.com/technomancy/better-defaults : "[...] this package
attempts to address the most obvious of deficiencies in uncontroversial ways
that nearly everyone can agree upon."

#+begin_src emacs-lisp
(use-package better-defaults
  :ensure t
  :config
  (ido-mode -1))  ; I prefer ivy-mode
#+end_src

** Store customizations in a separate file

#+begin_src emacs-lisp
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
(when (file-exists-p custom-file)
  (load custom-file))
#+end_src

** Remove trailing whitespace on save

#+begin_src emacs-lisp
(add-hook 'before-save-hook #'delete-trailing-whitespace)
#+end_src

** Kill the current buffer without confirmation

#+begin_src emacs-lisp
(bind-key "C-x k" #'kill-current-buffer)
#+end_src

** Enable some commands that are disabled by default

#+begin_src emacs-lisp
(put 'upcase-region 'disabled nil)
(put 'downcase-region 'disabled nil)
(put 'narrow-to-region 'disabled nil)
#+end_src

** Unify the way Emacs is asking for confirmation

#+begin_src emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+end_src

** Prevent suspending

Suspending Emacs causes EXWM to freeze. You can recover by sending =SIGUSR2= to
the running emacsclient process, but that is rather cumbersome.

#+begin_src emacs-lisp
(global-unset-key (kbd "C-z"))
(global-unset-key (kbd "C-x C-z"))
#+end_src

* Navigation and editing

** Boon: modal editing

#+begin_src emacs-lisp
(use-package boon
  :ensure t
  :demand t
  :diminish boon-local-mode
  :config
  (require 'boon-emacs)

  (bind-key "h" #'avy-goto-subword-1 boon-command-map)
  (bind-key "v" #'scroll-up-command boon-command-map)
  (bind-key "V" #'scroll-down-command boon-command-map)
  (bind-key "/" #'occur boon-command-map)
  (bind-key "\\" #'indent-region boon-command-map)
  (bind-key "@" #'boon-switch-mark boon-command-map)

  (bind-key "f" #'consult-flymake boon-goto-map)

  (boon-mode))
#+end_src

** Avy

#+begin_src emacs-lisp
(use-package avy
  :ensure t
  :bind (("M-g g" . avy-goto-line)
         ("M-g M-g" . avy-goto-line)))
#+end_src

** yasnippet

#+begin_src emacs-lisp
(use-package yasnippet
  :ensure t
  :config
  (yas-global-mode)
  :diminish yas-minor-mode)

(use-package yasnippet-snippets
  :ensure t)
#+end_src

** undo-tree

#+begin_src emacs-lisp
(use-package undo-tree
  :ensure t
  :config
  (global-undo-tree-mode)
  (setq undo-tree-visualizer-diff t)
  :diminish undo-tree-mode)
#+end_src

** (Auto-)Filling

#+begin_src emacs-lisp
(setq-default fill-column 79)
#+end_src

** Vertico and friends

#+begin_src emacs-lisp
(use-package vertico
  :ensure t
  :init
  (vertico-mode)
  :config
  (setq vertico-cycle t))

(use-package marginalia
  :ensure t
  :init
  (marginalia-mode))

(use-package orderless
  :ensure t
  :custom
  (completion-styles '(orderless basic))
  (completion-category-overrides '((file (styles basic partial-completion)))))
#+end_src

** Consult

#+begin_src emacs-lisp
(use-package consult
  :ensure t
  :bind (("C-x b" . consult-buffer)
         ("C-x p b" . consult-project-buffer)
         ("M-y" . consult-yank-pop)
         ("M-g i" . consult-imenu)
         ("M-g I" . consult-imenu-multi)
         ("M-g o" . consult-outline)
         ("M-g f" . consult-flymake)
         ("M-s g" . consult-ripgrep)))
#+end_src

** Completion

#+begin_src emacs-lisp
(use-package emacs
  :bind ("C-." . completion-at-point))

(use-package cape
  :ensure t
  :init
  (add-to-list 'completion-at-point-functions #'cape-dabbrev))

(use-package corfu
  :ensure t
  :custom
  (corfu-auto t)
  :init
  (global-corfu-mode))
#+end_src

* Project management

** project.el

#+begin_src emacs-lisp
(use-package project
  :init
  (setq project-switch-commands
        '((project-find-file "Find file")
          (project-find-regexp "Find regexp")
          (project-find-dir "Find directory")
          (project-eshell "Eshell")
          (magit-project-status "Magit" ?m))))
#+end_src

** direnv

#+begin_src emacs-lisp
(use-package direnv
  :ensure t
  :config
  (setq direnv-always-show-summary nil)
  (direnv-mode))
#+end_src

* Org

** Use current version of =org= and =org-contrib=

#+begin_src emacs-lisp
(use-package org
  :ensure t)

(use-package org-contrib
  :ensure t)
#+end_src

** Basic configuration

#+begin_src emacs-lisp
(setq org-directory "~/org/"
      org-agenda-files '("~/org/main.org" "~/org/tickler.org" "~/org/areas/")
      org-refile-use-outline-path 'file
      org-outline-path-complete-in-steps nil
      org-refile-targets '((nil . (:maxlevel . 2))
                           ("~/org/inbox.org" . (:level . 0))
                           ("~/org/cookbook.org" . (:level . 0))
                           ("~/org/pap.org" . (:maxlevel . 1))
                           (org-agenda-files . (:maxlevel . 2))
                           ("~/org/calendars/personal.org" . (:level . 0))
                           ("~/org/calendars/puzzleandplay.org" . (:level . 0))
                           ("~/org/bookmarks.org" . (:maxlevel . 1)))
      org-todo-keywords '((sequence "TODO(t)" "NEXT(n)" "WAITING(w)" "|" "DONE(d)" "CANCELLED(c)")))

;; This list contains tags I want to use in almost any file as they are tied to
;; actionable items (e.g. GTD contexts).
(setq org-tag-alist `((:startgroup)
                      ("@laptop" . ,(string-to-char "l"))
                      ("@phone" . ,(string-to-char "p"))
                      ("@home" . ,(string-to-char "h"))
                      ("@errands" . ,(string-to-char "e"))
                      (:endgroup)))

(setq org-startup-folded 'content
      org-log-into-drawer t
      org-agenda-todo-ignore-scheduled 'all
      org-agenda-todo-ignore-deadlines 'all
      org-agenda-tags-todo-honor-ignore-options t
      org-agenda-window-setup 'current-window
      org-agenda-restore-windows-after-quit nil
      org-time-clocksum-format "%d:%02d"
      org-duration-format 'h:mm
      org-enforce-todo-dependencies t
      org-columns-default-format "%40ITEM(Task) %3Priority(Pr.) %16Effort(Estimated Effort){:} %CLOCKSUM{:}"
      org-export-with-sub-superscripts nil
      org-export-allow-bind-keywords t
      org-default-priority ?C
      org-insert-heading-respect-content t)
#+end_src

** Capturing

*** Templates

#+begin_src emacs-lisp
(setq org-capture-templates
      '(("i" "Inbox" entry (file "~/org/inbox.org")
         "* %?\nCreated: %U")
        ("I" "Inbox (with link)" entry (file "~/org/inbox.org")
         "* %?\n%a\nCreated: %U")))

(use-package ol-notmuch)
#+end_src

*** Use the same window

#+begin_src emacs-lisp
(use-package org-capture
  :config
  (defun dkellner/org-pop-to-buffer (&rest args)
    "Use `pop-to-buffer' instead of `switch-to-buffer' to open buffer.'"
    (let ((buf (car args)))
      (pop-to-buffer
       (cond ((stringp buf) (get-buffer-create buf))
             ((bufferp buf) buf)
             (t (error "Invalid buffer %s" buf))))))

  (advice-add #'org-switch-to-buffer-other-window
              :override #'dkellner/org-pop-to-buffer)

  (defun dkellner/org-capture-place-template (oldfun &rest args)
    "Don't delete other windows in `org-capture-place-template'."
    (cl-letf (((symbol-function #'delete-other-windows) #'ignore))
      (apply oldfun args)))

  (advice-add #'org-capture-place-template
              :around #'dkellner/org-capture-place-template))
#+end_src

*** Capture buffers should start in insert state

#+begin_src emacs-lisp
(use-package org
  :after boon
  :hook (org-capture-mode . boon-set-insert-like-state))
#+end_src

** Agenda

*** Customizing the agenda view

#+begin_src emacs-lisp
(setq org-agenda-use-time-grid nil
      org-agenda-custom-commands
      '(("h" "Home"
         ((agenda "" ((org-agenda-span 'day)))
          (todo "TODO"
                ((org-agenda-sorting-strategy
                  '(priority-down tag-up))))))
        ("w" "Work"
         ((agenda "" ((org-agenda-span 'day)))
          (todo "TODO"
                ((org-agenda-sorting-strategy
                  '(priority-down tag-up)))))
         ((org-agenda-files
           (append org-agenda-files '("~/org/pap.org" "~/org/calendars/puzzleandplay.org")))
          (org-super-agenda-groups
           (append org-super-agenda-groups '((:name "@work" :tag "@work"))))))))

(use-package org-super-agenda
  :ensure t
  :config
  (setq org-super-agenda-groups
        '((:name "@laptop"
                 :tag "@laptop")
          (:name "@phone"
                 :tag "@phone")
          (:name "@home"
                 :tag "@home")
          (:name "@errands"
                 :tag "@errands")))
  (org-super-agenda-mode 1))
#+end_src

** Habits

#+begin_src emacs-lisp
(require 'org-habit)
#+end_src

** Keybindings

#+begin_src emacs-lisp
(bind-key "C-c a" #'org-agenda)
(bind-key "C-c c" #'org-capture)
(bind-key "C-c l" #'org-store-link)
#+end_src

** Literate Programming

#+begin_src emacs-lisp
(setq org-src-tab-acts-natively t
      org-edit-src-content-indentation 0
      org-confirm-babel-evaluate nil)

(org-babel-do-load-languages
 'org-babel-load-languages
 '((emacs-lisp . t)
   (shell . t)
   (python . t)))
#+end_src

** Expand snippets like "<s"

#+begin_src emacs-lisp
(require 'org-tempo)
#+end_src

** Prettification

#+begin_src emacs-lisp
(setq
 org-ellipsis " ⤵"
 org-agenda-block-separator 9472)

(use-package org-bullets
  :ensure t
  :hook (org-mode . org-bullets-mode)
  :config
  (setq org-bullets-bullet-list '("◉" "❃" "✿" "✤")))
#+end_src

** Use org-mode for =*scratch*=

#+begin_src emacs-lisp
(setq initial-major-mode 'org-mode
      initial-scratch-message nil)
#+end_src

** Visual indentation instead of actual spaces

#+begin_src emacs-lisp
(use-package org-indent
  :hook (org-mode . org-indent-mode)
  :diminish)
#+end_src

** org-store-link für qutebrowser

#+begin_src emacs-lisp
(defun dkellner/exwm-get-qutebrowser-url ()
  "Rather crude way of extracting the current URL in qutebrowser.

In qutebrowser, 'u' has to be bound to 'yank pretty-url'."
  (exwm-input--fake-key 'u)
  (sleep-for 0.05)
  (gui-backend-get-selection 'CLIPBOARD 'STRING))

(defun dkellner/org-store-link-qutebrowser ()
  "Store a link to the url of a qutebrowser buffer."
  (when (and (equal major-mode 'exwm-mode)
             (string= exwm-instance-name "qutebrowser"))
    (org-store-link-props
     :type "http"
     :link (dkellner/exwm-get-qutebrowser-url)
     :description exwm-title)))

(use-package org
  :config
  (org-link-set-parameters "http" :store #'dkellner/org-store-link-qutebrowser))
#+end_src

** Save org-mode buffers after refiling

#+begin_src emacs-lisp
(use-package org
  :config
  (advice-add #'org-refile :after #'org-save-all-org-buffers))
#+end_src

* Magit

#+begin_src emacs-lisp
(use-package magit
  :ensure t
  :config
  (setq magit-display-buffer-function
        #'magit-display-buffer-same-window-except-diff-v1)
  (magit-auto-revert-mode 1))
#+end_src

* E-Mail

#+begin_src emacs-lisp
(defun dkellner/fetch-mail ()
  "Fetch mail."
  (interactive)
  (async-shell-command "~/hacks/fetch-and-index-mail.sh"))

(use-package notmuch
  :ensure t
  :config
  (setq mail-host-address (system-name)
        sendmail-program "msmtp"
        message-kill-buffer-on-exit t
        message-send-mail-function 'message-send-mail-with-sendmail
        message-sendmail-extra-arguments '("--read-envelope-from")
        message-sendmail-f-is-evil t
        notmuch-fcc-dirs '(("dominik.kellner@fotopuzzle.de"
                            . "puzzleandplay/.sent")
                           (".*" . "dkellner/.sent"))))
#+end_src

* UI

** Themes

Everybody's got one: their favorite theme. In my case I've always configured at
least a dark and a light one, and I switch between them based on lighting
conditions (e.g. when I'm working outside I'm likely to use the light theme).

This is another area where going "all-in" Emacs really shines: Switching your
theme will conveniently affect *all* of your computing.

#+begin_src emacs-lisp
(setq custom--inhibit-theme-enable nil)

(use-package color-theme-sanityinc-tomorrow
  :ensure t
  :config
  (load-theme 'sanityinc-tomorrow-night t)
  (custom-theme-set-faces
   'sanityinc-tomorrow-night
   '(fringe ((t (:background nil))))
   '(org-block ((t (:background nil))))))
#+end_src

** Font

#+begin_src emacs-lisp
(add-to-list 'default-frame-alist '(font . "Meslo LG M 12"))
#+end_src

** Mode-line

#+begin_src emacs-lisp
(use-package all-the-icons
  :ensure t)

(column-number-mode 1)
(setq mode-line-position
      '((line-number-mode ("%l" (column-number-mode ":%c"))))
      eol-mnemonic-unix nil)
(setq-default mode-line-format
              '("%e"
                mode-line-front-space

                (:eval (when current-input-method-title
                         (format "%s " current-input-method-title)))

                mode-line-client

                (:eval
                 (let* ((props (-concat `(:height ,(/ all-the-icons-scale-factor 1.6)
                                                  :v-adjust 0)
                                        (cond
                                         (buffer-read-only '(:face (:foreground "gray85")))
                                         ((buffer-modified-p) '(:face (:foreground "red"))))))
                        (icon (apply #'all-the-icons-icon-for-mode
                                     (-concat (list major-mode) props))))
                   (if (not (eq icon major-mode)) icon
                     (apply #'all-the-icons-icon-for-mode 'text-mode props))))

                " "
                mode-line-buffer-identification
                " "
                mode-line-position
                " "
                mode-line-modes

                mode-line-misc-info
                mode-line-end-spaces))
#+end_src

** Remove distractions

When you're using =unclutter= or similar to hide the mouse pointer, then setting
=mouse-highlight= to =nil= is a must. Without, e.g. the agenda buffer will still
keep highlighting the line the now invisible pointer is on.

#+begin_src emacs-lisp
(diminish 'auto-revert-mode)
(setq mouse-highlight nil
      ring-bell-function 'ignore)
#+end_src

** Fringe and internal borders

#+begin_src emacs-lisp
(add-to-list 'default-frame-alist '(internal-border-width . 7))

(use-package fringe
  :config
  (fringe-mode '(7 . 1)))
#+end_src

* Browsing the web

** Qutebrowser

#+begin_src emacs-lisp
(defun dkellner/browse-url-qutebrowser (url &optional new-window)
  "Ask qutebrowser to load URL."
  (interactive (browse-url-interactive-arg "URL: "))
  (let* ((url (browse-url-encode-url url))
         (process-environment (browse-url-process-environment)))
    (apply 'start-process
           (concat "qutebrowser " url)
           nil
           "qutebrowser"
           (list "--override-restore" "--target" "window" url))))
#+end_src

** Set up a Hydra

#+begin_src emacs-lisp
(setq browse-url-browser-function #'browse-url-firefox)

(defun dkellner/browse-url-interactive-arg (prompt)
  (let ((url-at-point (lambda () (thing-at-point 'url t))))
    (advice-add 'browse-url-url-at-point :override url-at-point)
    (prog1
        (browse-url-interactive-arg prompt)
      (advice-remove 'browse-url-url-at-point url-at-point))))

(defun dkellner/browse-url (url-or-query &rest args)
  "Ask a WWW browser to load URL-OR-QUERY.

This behaves like `browse-url', with some differences:

1. It sets `default-directory' of the browser buffer to
\"~/\". This way the browser buffers will not be associated with
any projects by Projectile.

2. It overrides `browse-url-url-at-point' so that it only uses
real URLs as default, not prefixing any possible filename with
\"http://\".

3. If URL-OR-QUERY contains spaces, it is considered a search
query and opened with a search engine."
  (interactive (dkellner/browse-url-interactive-arg "URL: "))
  (let ((default-directory "~/")
        (url (if (cl-search " " url-or-query)
                 (format "https://duckduckgo.com/?q=%s" (url-encode-url url-or-query))
               url-or-query)))
    (apply #'browse-url url args)))

(defhydra dkellner/browse (:exit t)
  "Browse"
  ("o" #'dkellner/browse-url "url or query")
  ("b" #'dkellner/open-browser-bookmark "bookmark")
  ("we" (dkellner/search-online
         "https://www.wikipedia.org/search-redirect.php?language=en&go=Go&search=%s")
   "wikipedia")
  ("wd" (dkellner/search-online
         "https://www.wikipedia.org/search-redirect.php?language=de&go=Go&search=%s")
   "wikipedia"))
#+end_src

** Bookmarks with org-mode

#+begin_src emacs-lisp
(require 'map)

(bind-key "C-c b" #'dkellner/open-browser-bookmark)

(defcustom dkellner-browser-bookmarks-file "~/org/bookmarks.org"
  "Org-file containing bookmarks as HTTP(S)-URLs.

Currently only a very strict structure is supported, i.e. the
first level headlines will be treated as sections/groups and the
second level ones as bookmarks.")

(defun dkellner/open-browser-bookmark ()
  "Interactively selects and opens a bookmark in the default browser.

It uses `org-open-link-from-string' and thus `browse-url'
internally for actually sending the URL to the browser. You
should refer to its documentation if you want to change the
browser."
  (interactive)
  (let ((bookmarks (dkellner/browser-bookmarks-in-org-file
                    dkellner-browser-bookmarks-file)))
    (ivy-read "Open bookmark: " (map-keys bookmarks)
              :require-match t
              :action (lambda (e) (org-open-link-from-string
                                   (cdr (assoc e bookmarks)))))))

(defun dkellner/browser-bookmarks-in-org-file (org-file)
  (with-current-buffer (find-file-noselect (expand-file-name org-file))
    (org-element-map (org-element-parse-buffer) 'headline
      (lambda (h)
        (when (= (org-element-property :level h) 2)
          (dkellner/browser-bookmark-to-key-value h))))))

(defun dkellner/browser-bookmark-to-key-value (bookmark)
  (let* ((section (org-element-property :parent bookmark))
         (section-prefix (concat (org-element-property :raw-value section)
                                 " :: "))
         (raw-value (org-element-property :raw-value bookmark))
         (regexp "\\[\\[\\(.+?\\)]\\[\\(.+?\\)]]"))
    (if (string-match regexp raw-value)
        `(,(concat section-prefix (match-string 2 raw-value)) .
          ,(match-string 1 raw-value))
      `(,(concat section-prefix raw-value) . ,raw-value))))

(defun dkellner/search-online (search-engine-url)
  (let ((query (url-encode-url (read-string "Query: "))))
  (dkellner/browse-url (format search-engine-url query))))
#+end_src

* Programming

** LSP

#+begin_src emacs-lisp
(use-package lsp-mode
  :ensure t
  :after boon
  :config
  (bind-key "l" lsp-command-map boon-command-map)
  :custom
  (lsp-enable-suggest-server-download nil)
  (lsp-enable-symbol-highlighting nil)
  (lsp-signature-auto-activate nil)
  (lsp-eldoc-render-all nil)
  (lsp-idle-delay 0.6)
  (lsp-modeline-diagnostics-scope :workspace)
  (lsp-headerline-breadcrumb-enable nil)
  (lsp-lens-enable nil)
  (lsp-rust-analyzer-cargo-watch-command "clippy")
  (lsp-rust-analyzer-server-display-inlay-hints nil)
  (lsp-rust-analyzer-proc-macro-enable t))
#+end_src

* Language support

** Clojure

#+begin_src emacs-lisp
(use-package cider
  :ensure t)
#+end_src

** Docker

#+begin_src emacs-lisp
(use-package dockerfile-mode
  :ensure t)
#+end_src

** Lisp

#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :ensure t
  :hook ((emacs-lisp-mode . rainbow-delimiters-mode)
         (clojure-mode . rainbow-delimiters-mode)))
#+end_src

** Emacs Lisp

#+begin_src emacs-lisp
(use-package eldoc
  :hook (emacs-lisp-mode . eldoc-mode)
  :diminish)

(use-package macrostep
  :ensure t
  :bind (:map emacs-lisp-mode-map
              ("C-c e" . macrostep-expand)))

;; Make the use of sharp-quote more convenient.
;; See http://endlessparentheses.com/get-in-the-habit-of-using-sharp-quote.html
(defun endless/sharp ()
  "Insert #' unless in a string or comment."
  (interactive)
  (call-interactively #'self-insert-command)
  (let ((ppss (syntax-ppss)))
    (unless (or (elt ppss 3)
                (elt ppss 4)
                (eq (char-after) ?'))
      (insert "'"))))
(bind-key "#" #'endless/sharp emacs-lisp-mode-map)
#+end_src

** Go
See https://emacs.blog/2022/02/20/golang-ide-setup-in-emacs/

#+begin_src emacs-lisp
(use-package go-mode
  :ensure t)
#+end_src
** Markdown

#+begin_src emacs-lisp
(use-package markdown-mode
  :ensure t)
#+end_src

** Nix

#+begin_src emacs-lisp
(use-package nix-mode
  :ensure t
  :mode ("\\.nix\\'" . nix-mode))
#+end_src

** PHP, HTML

#+begin_src emacs-lisp
(use-package web-mode
  :ensure t
  :config
  (add-to-list 'auto-mode-alist '("\\.php\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.html\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.phtml\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.tpl\\.php\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.[agj]sp\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.as[cp]x\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode))
  (setq-default web-mode-markup-indent-offset 2)
  (setq-default web-mode-css-indent-offset 2)
  (setq-default web-mode-code-indent-offset 2))
#+end_src

** Rust

See https://robert.kra.hn/posts/2021-02-07_rust-with-emacs/

#+begin_src emacs-lisp
(use-package rustic
  :ensure t
  :config
  (setq rustic-format-on-save nil))
#+end_src

** YAML

#+begin_src emacs-lisp
(use-package yaml-mode
  :ensure t)

(use-package highlight-indentation
  :ensure t
  :hook (yaml-mode . highlight-indentation-current-column-mode)
  :diminish highlight-indentation-current-column-mode)
#+end_src

* Misc

** Shutdown and reboot

Simply running =shutdown -h now= in a terminal will cause Emacs to not shutdown
properly. For example, the list of recently used files will not be persisted.

=dkellner/prepare-kill-and-run= solves this by placing the actual shutdown
command at the end of =kill-emacs-hook=. This way it is executed just before
Emacs would exit normally.

#+begin_src emacs-lisp
(defhydra dkellner/shutdown-or-reboot (:exit t)
  "Shutdown/reboot/exit?"
  ("s" #'dkellner/shutdown "shutdown")
  ("r" #'dkellner/reboot "reboot")
  ("x" #'dkellner/exit-sway "exit sway"))

(defun dkellner/shutdown ()
  "Kills emacs properly and shutdown."
  (interactive)
  (dkellner/prepare-kill-and-run "shutdown -h now"))

(defun dkellner/reboot ()
  "Kill emacs properly and reboot."
  (interactive)
  (dkellner/prepare-kill-and-run "shutdown -r now"))

(defun dkellner/exit-sway ()
  "Kill emacs properly and exit sway."
  (interactive)
  (dkellner/prepare-kill-and-run "swaymsg exit"))

(defun dkellner/prepare-kill-and-run (command)
  "Prepare to kill Emacs properly and execute COMMAND.

This allows us to shutting down or rebooting the whole system and still
saving recently used files, bookmarks, places etc."
  (when (org-clock-is-active)
    (org-clock-out))
  (let ((kill-emacs-hook (append (remove #'server-force-stop kill-emacs-hook)
                                 (list (lambda () (shell-command command))))))
    (save-buffers-kill-emacs)))
#+end_src

** Helpful

#+begin_src emacs-lisp
(use-package helpful
  :ensure t
  :config
  (global-set-key (kbd "C-h f") #'helpful-callable)
  (global-set-key (kbd "C-h F") #'helpful-function)
  (global-set-key (kbd "C-h v") #'helpful-variable)
  (global-set-key (kbd "C-h k") #'helpful-key)
  (global-set-key (kbd "C-h C") #'helpful-command))
#+end_src

** pdf-tools

#+begin_src emacs-lisp
(use-package pdf-tools
  :ensure t
  :config
  (require 'pdf-occur)
  (pdf-tools-install-noverify))
#+end_src

** diff-hl

#+begin_src emacs-lisp
(use-package diff-hl
  :ensure t
  :hook (((prog-mode conf-mode) . turn-on-diff-hl-mode)
         (magit-post-refresh . diff-hl-magit-post-refresh))
  :config
  (setq diff-hl-draw-borders t))
#+end_src

** recentf

Auto-cleanup of recently used files is disabled, because it causes freezes when
remote files are not accessible anymore.

#+begin_src emacs-lisp
(use-package recentf
  :demand t
  :config
  (setq recentf-max-saved-items 250
        recentf-auto-cleanup 'never)
  (add-to-list 'recentf-exclude no-littering-etc-directory)
  (add-to-list 'recentf-exclude no-littering-var-directory)
  (add-to-list 'recentf-exclude "^/\\(?:ssh\\|su\\|sudo\\)?:")
  (recentf-mode 1))
#+end_src

** olivetti-mode

Olivetti is a nice little mode if you want to focus on writing one document.

#+begin_src emacs-lisp
(use-package olivetti
  :ensure t
  :custom
  (olivetti-body-width 90))
#+end_src

** Dired

#+begin_src emacs-lisp
(use-package dired
  :config
  (require 'dired-x)
  (setq dired-listing-switches "-ahl"
        dired-omit-files "^\\.")
  (add-hook 'dired-mode-hook
            (lambda () (dired-omit-mode))))
#+end_src

** savehist

#+begin_src emacs-lisp
(use-package savehist
  :init
  (savehist-mode))
#+end_src

** consult-ssh
#+begin_src emacs-lisp
(defun dkellner/open-ssh-term (&optional initial-input)
  "Run `ssh` for a hosts configured in ~/.ssh/config.
INITIAL-INPUT can be given as the initial minibuffer input."
  (interactive)
  (let ((host (completing-read "ssh " (dkellner/list-ssh-hosts))))
    (dkellner/term-command "ssh" host)))

(defun dkellner/list-ssh-hosts ()
  "Return all hosts defined in `~/.ssh/config` as list."
  (with-temp-buffer
    (insert-file-contents (s-concat (getenv "HOME") "/.ssh/config"))
    (keep-lines "^Host [^*]")
    (-map (lambda (line)
            (s-chop-prefix "Host " line))
          (s-split "\n" (buffer-string) t))))
#+end_src

* Performance shenanigans

** Startup

*** Inhibit implied frame resizing

#+begin_src emacs-lisp
(setq frame-inhibit-implied-resize t)
#+end_src

** Always use left-to-right text

#+begin_src emacs-lisp
(setq-default bidi-paragraph-direction 'left-to-right)
#+end_src

** GC-Tuning

#+begin_src emacs-lisp
(setq gc-cons-threshold (* 100 1024 1024))
#+end_src

** Read bigger chunks from external processes

#+begin_src emacs-lisp
(setq read-process-output-max (* 4 1024 1024))
#+end_src

* Playground

Often I get quite excited about all the great new packages out there and try
them out immediately. Sometimes only to find myself forgetting about these new
additions to my config and then they go unnoticed until I stumple upon them
again months later.

This section is there to prevent it: I'm adding new packages, snippets
etc. here for the purpose of reevaluating their usefulness after some time. If
I don't use it as often as I thought I would, I just discard it
again. Otherwise, I will move the entire section to a better place.

** vlf

#+begin_src emacs-lisp
(use-package vlf
  :ensure t)
#+end_src

** which-key

#+begin_src emacs-lisp
(use-package which-key
  :ensure t
  :diminish
  :config
  (which-key-mode))
#+end_src

** hledger-mode

#+begin_src emacs-lisp
(use-package hledger-mode
  :ensure t
  :demand t
  :mode ("\\.journal\\'" "\\.hledger\\'")
  :hook (hledger-mode . (lambda () (setq-local tab-width 4)))
  :config
  (setq hledger-currency-string "EUR"))
#+end_src

** Customize startup

#+begin_src emacs-lisp
(setq inhibit-startup-screen t
      inhibit-startup-echo-area-message t
      inhibit-startup-message t)
#+end_src

** org-roam

#+begin_src emacs-lisp
(use-package org-roam
  :ensure t
  :hook (after-init . org-roam-setup)
  :diminish
  :init (setq org-roam-v2-ack t)
  :config
  (setq org-roam-directory "~/org/roam"
        emacsql-sqlite3-executable (executable-find "sqlite3")
        org-roam-capture-templates
        '(("d" "default" plain "%?" :if-new
           (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n")
           :unnarrowed t
           :immediate-finish t)))

  (defhydra dkellner/org-roam (:exit t)
    "org-roam"
    ("f" #'org-roam-node-find "find")
    ("i" #'org-roam-node-insert "insert")
    ("b" #'org-roam-buffer-toggle "backlinks"))

  (bind-key* "C-c r" #'dkellner/org-roam/body))
#+end_src

#+end_src

** Pomidor

#+begin_src emacs-lisp
(use-package alert
  :ensure t
  :config
  (setq alert-default-style 'notifications))

(use-package pomidor
  :ensure t
  :bind (("<XF86Favorites>" . pomidor))
  :config
  (setq pomidor-play-sound-file nil))
#+end_src

** dict

I've recently set up a `dictd` instance backed by wordnet on my machine and am
still figuring out how best to use it. For starters, a function for calling the
`dict` binary:

#+begin_src emacs-lisp
(defun dkellner/dict-lookup-word (word)
  (interactive (list
                (read-string (format "Word (%s): " (thing-at-point 'word))
                             nil nil (thing-at-point 'word))))
  (shell-command (format "dict -h localhost %s" word)))
#+end_src

* Meta

** Private configuration

#+begin_src emacs-lisp
(load "~/.emacs.d/private.el")
#+end_src

** Remind about tangling configuration on exit

#+begin_src emacs-lisp
(defun dkellner/tangle-if-outdated (filename)
  "Ask to tangle FILENAME if it its corresponding `.el` file is older."
  (let ((el-file (concat (file-name-sans-extension filename) ".el")))
    (when (and (file-newer-than-file-p filename el-file)
               (y-or-n-p (format "%s is outdated. Tangle %s?" el-file filename)))
      (save-excursion
        (find-file filename)
        (org-babel-tangle))))
  t)

(defun dkellner/tangle-config ()
  "Ask to tangle init.org and private.org, if necessary."
  (dkellner/tangle-if-outdated "~/.emacs.d/init.org")
  (dkellner/tangle-if-outdated "~/.emacs.d/private.org"))

(add-hook 'kill-emacs-query-functions #'dkellner/tangle-config)
#+end_src
