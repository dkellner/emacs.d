#+title: Emacs Configuration
#+author: Dominik Kellner
#+property: header-args :tangle yes
#+auto_tangle: t

* Initialization
#+begin_src emacs-lisp
;;; init.el --- user-init-file                    -*- lexical-binding: t -*-
;;;
;;; DO NOT EDIT THIS FILE!
;;; This file was automatically generated by tangling `init.org`.
#+end_src

* Package management
I use Nix with the [[https://github.com/nix-community/emacs-overlay][emacs overlay]] to build Emacs including packages directly
from =use-package= declarations in this file. Hence I "disable" the included
package manager to not accidentally install packages another way.

#+begin_src emacs-lisp
(setq package-archives nil)
#+end_src

* Common
These packages and functions are used by various other subsections.

** Keep ~/.emacs.d/ clean
=no-littering= needs to be loaded as early as possible, see
https://github.com/emacscollective/no-littering#usage for details.

#+begin_src emacs-lisp
(use-package no-littering
  :ensure t)

(when (fboundp 'startup-redirect-eln-cache)
  (startup-redirect-eln-cache
   (convert-standard-filename
    (expand-file-name  "var/eln-cache/" user-emacs-directory))))
#+end_src

** diminish
#+begin_src emacs-lisp
(use-package diminish
  :ensure t)
#+end_src

** hydra
#+begin_src emacs-lisp
(use-package hydra
  :ensure t)
#+end_src

** Run commands in an external terminal
#+begin_src emacs-lisp
(defun dkellner/term-command (cmd &rest args)
  (let* ((cmd-with-args (s-join " " (cons cmd args)))
         (name (format "alacritty: %s" cmd-with-args)))
  (apply #'start-process
         name
         (format "*%s*" name)
         "alacritty"
         "--title"
         cmd-with-args
         "--command"
         cmd
         args)))
#+end_src

** Run functions in dedicated frames
We set the title to "emacs-floating", so we can distinguish them from regular
emacs frames in our sway configuration.

#+begin_src emacs-lisp
(defun dkellner/run-in-dedicated-frame (fn)
  (let ((frame (make-frame '((title . "emacs-floating")))))
    (select-frame frame)
    (funcall fn)))

(defun dkellner/run-in-minibuffer-frame (fn)
  (let ((frame (make-frame '((minibuffer . only)
                             (title . "emacs-floating")))))
    (select-frame frame)
    (unwind-protect
        (funcall fn)
      (delete-frame frame))))

(defun dkellner/dedicated-frame-p ()
  (equal "emacs-floating" (frame-parameter nil 'title)))
#+end_src

* Sensible defaults
** A good starting point: `better-defaults`
From https://git.sr.ht/~technomancy/better-defaults: "[...] this package
attempts to address the most obvious of deficiencies in uncontroversial ways
that nearly everyone can agree upon."

#+begin_src emacs-lisp
(use-package better-defaults
  :ensure t
  :config
  (ido-mode -1))  ; I prefer vertico
#+end_src

** Load custom.el
#+begin_src emacs-lisp
(when (file-exists-p custom-file)
  (load custom-file))
#+end_src

** Revert buffers when files on disk change
#+begin_src emacs-lisp
(setq global-auto-revert-non-file-buffers t)
(global-auto-revert-mode 1)
#+end_src

** Remove trailing whitespace on save
#+begin_src emacs-lisp
(add-hook 'before-save-hook #'delete-trailing-whitespace)
#+end_src

** Kill the current buffer without confirmation
#+begin_src emacs-lisp
(bind-key "C-x k" #'kill-current-buffer)
#+end_src

** Enable some commands that are disabled by default
#+begin_src emacs-lisp
(put 'upcase-region 'disabled nil)
(put 'downcase-region 'disabled nil)
(put 'narrow-to-region 'disabled nil)
(put 'narrow-to-page 'disabled nil)
(put 'narrow-to-defun 'disabled nil)
#+end_src

** Unify the way Emacs is asking for confirmation
#+begin_src emacs-lisp
(setq use-short-answers t)
#+end_src

** recentf
Auto-cleanup of recently used files is disabled, because it causes freezes when
remote files are not accessible anymore. Call =recentf-cleanup= for manual
cleanup.

#+begin_src emacs-lisp
(use-package recentf
  :demand t
  :config
  (setq recentf-max-saved-items 250
        recentf-auto-cleanup 'never)
  (add-to-list 'recentf-exclude no-littering-etc-directory)
  (add-to-list 'recentf-exclude no-littering-var-directory)
  (add-to-list 'recentf-exclude "^/\\(?:sshx?\\|su\\|sudo\\)?:")
  (recentf-mode 1))
#+end_src

** Prevent suspending
#+begin_src emacs-lisp
(global-unset-key (kbd "C-z"))
(global-unset-key (kbd "C-x C-z"))
#+end_src

** Don't save duplicates in kill-ring
#+begin_src emacs-lisp
(setq kill-do-not-save-duplicates t)
#+end_src

** Skip asking for confirmation for async-shell-command
#+begin_src emacs-lisp
(use-package emacs
  :config
  (setopt async-shell-command-buffer 'new-buffer))
#+end_src

* Navigation and editing
** Boon: modal editing
#+begin_src emacs-lisp
(use-package boon
  :ensure t
  :load-path "~/dev/boon"
  :demand t
  :diminish boon-local-mode
  :config
  (setq boon-insert-conditions
        '((eq major-mode 'message-mode)
          (eq major-mode 'eshell-mode)
          (bound-and-true-p org-capture-mode)))
  (setq boon-special-conditions
        '((bound-and-true-p magit-blame-mode)
          (eq major-mode 'eat-mode)))

  (require 'boon-emacs)

  (define-key boon-command-map "l" 'dkellner/eglot-actions/body)
  (define-key boon-command-map "." 'embark-act)
  (define-key boon-command-map "," 'er/expand-region)
  (define-key boon-command-map "m" 'avy-goto-char-timer)

  (define-key boon-forward-search-map "m" 'dkellner/flymake-goto-next-error)
  (define-key boon-backward-search-map "m" 'dkellner/flymake-goto-prev-error)

  (boon-mode))
#+end_src

** Avy
#+begin_src emacs-lisp
(use-package avy
  :ensure t
  :bind (("M-g g" . avy-goto-line)
         ("M-g M-g" . avy-goto-line))
  :config
  (setq avy-keys '(?o ?d ?e ?t ?i ?n ?s ?r ?c ?h))
  (setq avy-all-windows t)
  (setq avy-orders-alist '((avy-goto-line . avy-order-closest)
                           (avy-goto-char-timer . avy-order-closest))))
#+end_src

** yasnippet
#+begin_src emacs-lisp
(use-package yasnippet
  :ensure t
  :demand t
  :config
  (yas-global-mode)
  :diminish yas-minor-mode)

(use-package yasnippet-snippets
  :ensure t)
#+end_src

** (Auto-)Filling
#+begin_src emacs-lisp
(setq-default fill-column 79)
#+end_src

** Vertico and friends
#+begin_src emacs-lisp
(use-package vertico
  :ensure t
  :config
  (setq vertico-cycle t)
  (vertico-mode 1)

  (vertico-multiform-mode 1)

  (setq vertico-multiform-commands
        '((consult-ripgrep buffer indexed))))

(use-package marginalia
  :ensure t
  :config
  (marginalia-mode))

(use-package orderless
  :ensure t
  :custom
  (completion-styles '(orderless basic))
  (completion-category-overrides '((file (styles basic partial-completion))))
  (orderless-smart-case nil))
#+end_src

** Consult
I disable the automatic preview for =consult-buffer=, because in combination
with =envrc-mode= Emacs hangs a couple of seconds evaluating when stepping over
completion candidates.

#+begin_src emacs-lisp
(use-package consult
  :ensure t
  :bind (("C-x b" . consult-buffer)
         ("C-x p b" . consult-project-buffer)
         ("M-y" . consult-yank-pop)
         ("M-g i" . consult-imenu)
         ("M-g I" . consult-imenu-multi)
         ("M-g o" . consult-outline)
         ("M-g f" . consult-flymake)
         ("M-s g" . consult-ripgrep))
  :config
  (consult-customize consult-buffer :preview-key "M-.")
  (setq consult-ripgrep-args
        (concat "rg "
                "--null "
                "--line-buffered "
                "--color=never "
                "--max-columns=1000 "
                "--path-separator / "
                "--smart-case "
                "--no-heading "
                "--with-filename "
                "--line-number "
                "--search-zip "
                "--hidden"  ; added by me
                )))
#+end_src

** Completion
#+begin_src emacs-lisp
(use-package corfu
  :ensure t
  :custom
  (corfu-cycle t)
  :config
  (global-corfu-mode))

(use-package cape
  :ensure t
  :init
  (add-to-list 'completion-at-point-functions #'cape-dabbrev))

(use-package emacs
  :init
  (setq tab-always-indent 'complete)
  (setq text-mode-ispell-word-completion nil)
  (setq read-extended-command-predicate #'command-completion-default-include-p)
  (setq completion-ignore-case t)
  (setq read-buffer-completion-ignore-case t)
  (setq read-file-name-completion-ignore-case t))
#+end_src

** multiple-cursors
#+begin_src emacs-lisp
(use-package multiple-cursors
  :ensure t
  :bind (("C-<" . mc/mark-all-like-this)
         ("C->" . mc/mark-next-like-this)))
#+end_src

** unfill
#+begin_src emacs-lisp
(use-package unfill
  :ensure t
  :bind ("M-q" . unfill-toggle))

** Indentation
#+begin_src emacs-lisp
(use-package simple
  :bind (("RET" . newline-and-indent)
         ("C-j" . newline)))

(use-package electric
  :config
  (electric-indent-mode -1))
#+end_src

* Project management
** project.el
#+begin_src emacs-lisp
(use-package project
  :config
  (setq project-switch-commands
        '((project-find-file "Find file")
          (project-find-regexp "Find regexp")
          (project-find-dir "Find directory")
          (project-eshell "Eshell")
          (magit-project-status "Magit" ?m))))
#+end_src

** direnv integration
#+begin_src emacs-lisp
(use-package envrc
  :ensure t
  :diminish
  :config
  (envrc-global-mode 1))
#+end_src

* Org
** Use current version of =org= and =org-contrib=
#+begin_src emacs-lisp
(use-package org
  :ensure t)

(use-package org-contrib
  :ensure t)
#+end_src

** Basic configuration
#+begin_src emacs-lisp
(setq org-directory "~/org/"
      org-agenda-files '("~/org/main.org" "~/org/tickler.org" "~/org/areas/")
      org-refile-use-outline-path 'file
      org-outline-path-complete-in-steps nil
      org-refile-targets '((nil . (:maxlevel . 2))
                           ("~/org/inbox.org" . (:level . 0))
                           ("~/org/cookbook.org" . (:level . 0))
                           ("~/org/pap.org" . (:maxlevel . 1))
                           (org-agenda-files . (:maxlevel . 2))
                           ("~/org/calendars/personal.org" . (:level . 0))
                           ("~/org/calendars/puzzleandplay.org" . (:level . 0))
                           ("~/org/bookmarks.org" . (:maxlevel . 1)))
      org-todo-keywords '((sequence "TODO(t)" "NEXT(n)" "WAITING(w)" "|" "DONE(d)" "CANCELLED(c)")))

;; This list contains tags I want to use in almost any file as they are tied to
;; actionable items (e.g. GTD contexts).
(setq org-tag-alist `((:startgroup)
                      ("@laptop" . ,(string-to-char "l"))
                      ("@phone" . ,(string-to-char "p"))
                      ("@home" . ,(string-to-char "h"))
                      ("@errands" . ,(string-to-char "e"))
                      ("@westwork" . ,(string-to-char "w"))
                      (:endgroup)))

(setq org-startup-folded 'content
      org-log-done 'time
      org-log-into-drawer t
      org-agenda-todo-ignore-scheduled 'all
      org-agenda-todo-ignore-deadlines 'all
      org-agenda-tags-todo-honor-ignore-options t
      org-agenda-window-setup 'current-window
      org-agenda-restore-windows-after-quit nil
      org-time-clocksum-format "%d:%02d"
      org-duration-format 'h:mm
      org-enforce-todo-dependencies t
      org-columns-default-format "%40ITEM(Task) %3Priority(Pr.) %16Effort(Estimated Effort){:} %CLOCKSUM{:}"
      org-export-with-sub-superscripts nil
      org-export-allow-bind-keywords t
      org-default-priority ?C
      org-insert-heading-respect-content t)

(use-package ox-latex
  :config
  (add-to-list 'org-latex-classes
               '("koma-article" "\\documentclass{scrartcl}"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))))
#+end_src

** Capturing
*** Templates
#+begin_src emacs-lisp
(setq org-capture-templates
      '(("i" "Inbox" entry (file "~/org/inbox.org")
         "* %?\nCreated: %U")
        ("I" "Inbox (with link)" entry (file "~/org/inbox.org")
         "* %?\n%a\nCreated: %U")))

(use-package ol-notmuch
  :ensure t)
#+end_src

** Agenda
*** Customizing the agenda view
#+begin_src emacs-lisp
(setq org-agenda-use-time-grid nil
      org-agenda-skip-scheduled-if-done t
      org-agenda-skip-deadline-if-done t
      org-agenda-custom-commands
      '(("h" "Home"
         ((agenda "" ((org-agenda-span 'day)))
          (todo "TODO"
                ((org-agenda-sorting-strategy
                  '(priority-down tag-up))))))
        ("w" "Work"
         ((agenda "" ((org-agenda-span 'day)))
          (todo "TODO"
                ((org-agenda-sorting-strategy
                  '(priority-down tag-up)))))
         ((org-agenda-files
           (append org-agenda-files '("~/org/pap.org" "~/org/calendars/puzzleandplay.org")))
          (org-super-agenda-groups
           (append org-super-agenda-groups '((:name "@work" :tag "@work"))))))))

(use-package org-super-agenda
  :ensure t
  :config
  (setq org-super-agenda-groups
        '((:name "@laptop"
                 :tag "@laptop")
          (:name "@phone"
                 :tag "@phone")
          (:name "@home"
                 :tag "@home")
          (:name "@errands"
                 :tag "@errands")))
  (org-super-agenda-mode 1))
#+end_src

** Habits
#+begin_src emacs-lisp
(require 'org-habit)
#+end_src

** Keybindings
#+begin_src emacs-lisp
(bind-key "C-c a" #'org-agenda)
(bind-key "C-c c" #'org-capture)
(bind-key "C-c l" #'org-store-link)
#+end_src

** Literate Programming
#+begin_src emacs-lisp
(setq org-src-tab-acts-natively t
      org-edit-src-content-indentation 0
      org-confirm-babel-evaluate nil)

(org-babel-do-load-languages
 'org-babel-load-languages
 '((emacs-lisp . t)
   (shell . t)
   (python . t)))
#+end_src

** Expand snippets like "<s"
#+begin_src emacs-lisp
(require 'org-tempo)
#+end_src

** Prettification
#+begin_src emacs-lisp
(setq
 org-ellipsis " ⤵"
 org-agenda-block-separator 9472)

(use-package org-bullets
  :ensure t
  :hook (org-mode . org-bullets-mode)
  :config
  (setq org-bullets-bullet-list '("◉" "❃" "✿" "✤")))
#+end_src

** Use org-mode for =*scratch*=
#+begin_src emacs-lisp
(setq initial-major-mode 'org-mode
      initial-scratch-message nil)
#+end_src

** Visual indentation instead of actual spaces
#+begin_src emacs-lisp
(use-package org-indent
  :hook (org-mode . org-indent-mode)
  :diminish)
#+end_src

** Save org-mode buffers after refiling
#+begin_src emacs-lisp
(use-package org
  :config
  (advice-add #'org-refile :after #'org-save-all-org-buffers))
#+end_src

** org-ql
#+begin_src emacs-lisp
(use-package org-ql
  :ensure t)

(defun dkellner/list-tasks-done-today ()
  (interactive)
  (let* ((today-str (format-time-string "%Y-%m-%d"))
         (pattern (concat "- State \"DONE\" *from \"TODO\" *\\[" today-str)))
    (org-ql-search (org-agenda-files)
      `(or (closed :on today)
           (regexp ,pattern)))))
#+end_src

** org-auto-tangle
#+begin_src emacs-lisp
(use-package org-auto-tangle
  :ensure t
  :hook (org-mode . org-auto-tangle-mode)
  :diminish)
#+end_src

* Magit
#+begin_src emacs-lisp
(use-package magit
  :ensure t
  :config
  (setq magit-display-buffer-function
        #'magit-display-buffer-same-window-except-diff-v1
        magit-section-initial-visibility-alist '((stashes . hide)
                                                 (unpushed . show))))
#+end_src

* E-Mail
#+begin_src emacs-lisp
(use-package notmuch
  :ensure t
  :config
  (setq mail-host-address (system-name)
        sendmail-program "msmtp"
        message-kill-buffer-on-exit t
        message-send-mail-function 'message-send-mail-with-sendmail
        message-sendmail-extra-arguments '("--read-envelope-from")
        message-sendmail-f-is-evil t
        notmuch-fcc-dirs '(("dominik.kellner@puzzleyou.de"
                            . "puzzleandplay/.sent")
                           (".*" . "dkellner/.sent"))))
#+end_src

* UI
** Themes
Everybody's got one: their favorite theme. In my case I've always configured at
least a dark and a light one, and I switch between them based on lighting
conditions (e.g. when I'm working outside I'm likely to use the light theme).

This is another area where going "all-in" Emacs really shines: Switching your
theme will conveniently affect *all* of your computing.

#+begin_src emacs-lisp
(setq custom--inhibit-theme-enable nil)

(use-package color-theme-sanityinc-tomorrow
  :ensure t
  :config
  (defun dkellner/load-light-theme ()
    (interactive)
    (disable-theme 'sanityinc-tomorrow-night)
    (load-theme 'sanityinc-tomorrow-day t)
    (custom-theme-set-faces
     'sanityinc-tomorrow-night
     '(fringe ((t (:background unspecified))))
     '(org-block ((t (:background unspecified))))))

  (defun dkellner/load-dark-theme ()
    (interactive)
    (disable-theme 'sanityinc-tomorrow-day)
    (load-theme 'sanityinc-tomorrow-night t)
    (custom-theme-set-faces
     'sanityinc-tomorrow-night
     '(fringe ((t (:background unspecified))))
     '(org-block ((t (:background unspecified))))))

  (defun dkellner/toggle-theme ()
    (interactive)
    (if (-contains? custom-enabled-themes 'sanityinc-tomorrow-night)
        (dkellner/load-light-theme)
      (dkellner/load-dark-theme)))

  (dkellner/load-dark-theme))
#+end_src

** Font
#+begin_src emacs-lisp
(add-to-list 'default-frame-alist '(font . "Meslo LG M 12"))
#+end_src

** Mode-line
#+begin_src emacs-lisp
(use-package all-the-icons
  :ensure t)

(column-number-mode 1)
(setq mode-line-position
      '((line-number-mode ("%l" (column-number-mode ":%c"))))
      eol-mnemonic-unix nil)
(setq-default mode-line-format
              '("%e"
                mode-line-front-space

                (:eval (when current-input-method-title
                         (format "%s " current-input-method-title)))

                mode-line-client

                (:eval
                 (let* ((props (-concat `(:height ,(/ all-the-icons-scale-factor 1.6)
                                                  :v-adjust 0)
                                        (cond
                                         (buffer-read-only '(:face (:foreground "gray85")))
                                         ((buffer-modified-p) '(:face (:foreground "red"))))))
                        (icon (apply #'all-the-icons-icon-for-mode
                                     (-concat (list major-mode) props))))
                   (if (not (eq icon major-mode)) icon
                     (apply #'all-the-icons-icon-for-mode 'text-mode props))))

                " "
                mode-line-buffer-identification
                " "
                mode-line-position
                " "
                mode-line-modes

                mode-line-misc-info
                mode-line-end-spaces))
#+end_src

** Remove distractions
When you're using =unclutter= or similar to hide the mouse pointer, then setting
=mouse-highlight= to =nil= is a must. Without, e.g. the agenda buffer will still
keep highlighting the line the now invisible pointer is on.

#+begin_src emacs-lisp
(diminish 'auto-revert-mode)
(setq mouse-highlight nil
      ring-bell-function 'ignore)
#+end_src

** Fringe and internal borders
#+begin_src emacs-lisp
(add-to-list 'default-frame-alist '(internal-border-width . 7))

(use-package fringe
  :config
  (fringe-mode '(7 . 1)))
#+end_src

** Transparency
#+begin_src emacs-lisp
(add-to-list 'default-frame-alist '(alpha-background . 95))
#+end_src

** Scrolling
#+begin_src emacs-lisp
(setq auto-window-vscroll nil
      fast-but-imprecise-scrolling t
      scroll-conservatively 101
      scroll-margin 3
      scroll-preserve-screen-position t)
#+end_src

** Customize startup
#+begin_src emacs-lisp
(setq inhibit-startup-screen t
      inhibit-startup-echo-area-message t
      inhibit-startup-message t)
#+end_src

** which-key
#+begin_src emacs-lisp
(use-package which-key
  :ensure t
  :diminish
  :config
  (which-key-mode))
#+end_src

** Buffer display rules
#+begin_src emacs-lisp
(use-package window
  :config
  (setq display-buffer-alist nil)
  (add-to-list 'display-buffer-alist
               '("^CAPTURE-.*"
                 (display-buffer-pop-up-frame)
                 (dedicated . t)
                 (pop-up-frame-parameters . '(name . "emacs-floating")))))
#+end_src

* Programming
** Common
#+begin_src emacs-lisp
(use-package eldoc
  :diminish
  :config
  (setq eldoc-echo-area-use-multiline-p nil))
#+end_src

** Flymake
#+begin_src emacs-lisp
(use-package flymake-diagnostic-at-point
  :ensure t
  :after flymake
  :hook (flymake-mode . flymake-diagnostic-at-point-mode))

(defun dkellner/flymake-goto-next-error ()
  "Call `flymake-goto-next-error' non-interactively to suppress
printing the error."
  (interactive)
  (flymake-goto-next-error))

(defun dkellner/flymake-goto-prev-error ()
  "Call `flymake-goto-prev-error' non-interactively to suppress
printing the error."
  (interactive)
  (flymake-goto-prev-error))
#+end_src

** LSP (eglot)
#+begin_src emacs-lisp
(use-package eglot
  :after yasnippet
  :config
  (add-to-list 'eglot-server-programs '(rust-ts-mode "rust-analyzer"))

  (defhydra dkellner/eglot-actions (:exit t)
    "Eglot"
    ("a" #'eglot-code-actions "code actions")
    ("f" #'eglot-format "format")
    ("r" #'eglot-rename "rename"))

  :hook ((eglot-managed-mode . (lambda () (eglot-inlay-hints-mode -1)))))

(use-package consult-eglot
  :ensure t)

(use-package eglot-booster
  :after eglot
  :config
  (eglot-booster-mode))
#+end_src

** Eshell
#+begin_src emacs-lisp
(use-package esh-mode
  :config
  (setq eshell-scroll-to-bottom-on-output t))

(use-package em-hist
  :bind (:map eshell-hist-mode-map
              ("C-c C-l" . consult-history))
  :config
  (setq eshell-history-size 1024))
#+end_src

* Language support
** Docker
#+begin_src emacs-lisp
(use-package dockerfile-mode
  :ensure t)
#+end_src

** Justfile
#+begin_src emacs-lisp
(use-package just-mode
  :ensure t)
#+end_src

** Lisp
#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :ensure t
  :hook ((emacs-lisp-mode . rainbow-delimiters-mode)))
#+end_src

** Emacs Lisp
#+begin_src emacs-lisp
(use-package macrostep
  :ensure t
  :bind (:map emacs-lisp-mode-map
              ("C-c e" . macrostep-expand)))

;; Make the use of sharp-quote more convenient.
;; See http://endlessparentheses.com/get-in-the-habit-of-using-sharp-quote.html
(defun endless/sharp ()
  "Insert #' unless in a string or comment."
  (interactive)
  (call-interactively #'self-insert-command)
  (let ((ppss (syntax-ppss)))
    (unless (or (elt ppss 3)
                (elt ppss 4)
                (eq (char-after) ?'))
      (insert "'"))))
(bind-key "#" #'endless/sharp emacs-lisp-mode-map)
#+end_src

** Go
#+begin_src emacs-lisp
(use-package go-mode
  :ensure t)
#+end_src

** Markdown
#+begin_src emacs-lisp
(use-package markdown-mode
  :ensure t)
#+end_src

** Nix
#+begin_src emacs-lisp
(use-package nix-mode
  :ensure t
  :mode ("\\.nix\\'" . nix-mode))
#+end_src

** PHP, HTML
#+begin_src emacs-lisp
(use-package web-mode
  :ensure t
  :config
  (add-to-list 'auto-mode-alist '("\\.php\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.html\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.phtml\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.tpl\\.php\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.[agj]sp\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.as[cp]x\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode))
  (setq-default web-mode-markup-indent-offset 2)
  (setq-default web-mode-css-indent-offset 2)
  (setq-default web-mode-code-indent-offset 2))
#+end_src

** Rust
#+begin_src emacs-lisp
(use-package rust-ts-mode
  :init
  (add-to-list 'auto-mode-alist '("\\.rs\\'" . rust-ts-mode))
  :hook (rust-ts-mode . eglot-ensure))
#+end_src

** YAML
#+begin_src emacs-lisp
(use-package yaml-mode
  :ensure t)

(use-package highlight-indentation
  :ensure t
  :hook (yaml-mode . highlight-indentation-current-column-mode)
  :diminish highlight-indentation-current-column-mode)
#+end_src

** OpenSCAD
#+begin_src emacs-lisp
(use-package scad-mode
  :ensure t)
#+end_src

* Misc
** Shutdown and reboot
Simply running =shutdown -h now= in a terminal will cause Emacs to not shutdown
properly. For example, the list of recently used files will not be persisted.

=dkellner/prepare-kill-and-run= solves this by placing the actual shutdown
command at the end of =kill-emacs-hook=. This way it is executed just before
Emacs would exit normally.

#+begin_src emacs-lisp
(defhydra dkellner/shutdown-or-reboot (:exit t)
  "Shutdown/reboot/exit?"
  ("s" #'dkellner/shutdown "shutdown")
  ("r" #'dkellner/reboot "reboot")
  ("x" #'dkellner/exit-sway "exit sway"))

(defun dkellner/shutdown ()
  "Kills emacs properly and shutdown."
  (interactive)
  (dkellner/prepare-kill-and-run "shutdown -h now"))

(defun dkellner/reboot ()
  "Kill emacs properly and reboot."
  (interactive)
  (dkellner/prepare-kill-and-run "shutdown -r now"))

(defun dkellner/exit-sway ()
  "Kill emacs properly and exit sway."
  (interactive)
  (dkellner/prepare-kill-and-run "swaymsg exit"))

(defun dkellner/prepare-kill-and-run (command)
  "Prepare to kill Emacs properly and execute COMMAND.

This allows us to shutting down or rebooting the whole system and still
saving recently used files, bookmarks, places etc."
  (when (org-clock-is-active)
    (org-clock-out))
  (let ((kill-emacs-hook (append (remove #'server-force-stop kill-emacs-hook)
                                 (list (lambda () (shell-command command))))))
    (save-buffers-kill-emacs)))
#+end_src

** Helpful
#+begin_src emacs-lisp
(use-package helpful
  :ensure t
  :config
  (global-set-key (kbd "C-h f") #'helpful-callable)
  (global-set-key (kbd "C-h F") #'helpful-function)
  (global-set-key (kbd "C-h v") #'helpful-variable)
  (global-set-key (kbd "C-h k") #'helpful-key)
  (global-set-key (kbd "C-h C") #'helpful-command))
#+end_src

** pdf-tools
#+begin_src emacs-lisp
(use-package pdf-tools
  :ensure t
  :config
  (require 'pdf-occur)
  (pdf-tools-install-noverify))
#+end_src

** diff-hl
#+begin_src emacs-lisp
(use-package diff-hl
  :ensure t
  :hook (((prog-mode conf-mode) . turn-on-diff-hl-mode)
         (magit-post-refresh . diff-hl-magit-post-refresh))
  :config
  (setq diff-hl-draw-borders t))
#+end_src

** consult-ssh
#+begin_src emacs-lisp
(defun dkellner/open-ssh-term ()
  "Run `ssh` for a hosts configured in ~/.ssh/config.
INITIAL-INPUT can be given as the initial minibuffer input."
  (interactive)
  (let ((host (completing-read "ssh " (pcmpl-ssh-hosts))))
    (dkellner/term-command "ssh" host)))
#+end_src

** Make shebang (#!) file executable when saved
#+begin_src emacs-lisp
(add-hook 'after-save-hook #'executable-make-buffer-file-executable-if-script-p)
#+end_src

** Better completions for Eshell
#+begin_src emacs-lisp
(use-package pcmpl-args
  :ensure t)
#+end_src

** dired
#+begin_src emacs-lisp
(use-package emacs
  :bind
  ("C-x C-d" . dired)
  :config
  (setq dired-omit-files (rx (seq bol "."))))
#+end_src

* Performance shenanigans
** Startup
*** Inhibit implied frame resizing
#+begin_src emacs-lisp
(setq frame-inhibit-implied-resize t)
#+end_src

** Better support for files with long lines
#+begin_src emacs-lisp
(setq-default bidi-paragraph-direction 'left-to-right
              bidi-inhibit-bpa t)
(global-so-long-mode 1)
#+end_src

** GC-Tuning
#+begin_src emacs-lisp
(setq gc-cons-threshold (* 16 1024 1024))
#+end_src

** Read bigger chunks from external processes
#+begin_src emacs-lisp
(setq read-process-output-max (* 1024 1024))
#+end_src

* Playground
Often I get quite excited about all the great new packages out there and try
them out immediately. Sometimes only to find myself forgetting about these new
additions to my config and then they go unnoticed until I stumple upon them
again months later.

This section is there to prevent it: I'm adding new packages, snippets
etc. here for the purpose of reevaluating their usefulness after some time. If
I don't use it as often as I thought I would, I just discard it
again. Otherwise, I will move the entire section to a better place.

** vlf
#+begin_src emacs-lisp
(use-package vlf
  :ensure t)
#+end_src

** hledger-mode
#+begin_src emacs-lisp
(use-package hledger-mode
  :ensure t
  :demand t
  :mode ("\\.journal\\'" "\\.hledger\\'")
  :hook (hledger-mode . (lambda () (setq-local tab-width 4)))
  :config
  (setq hledger-currency-string "EUR"))
#+end_src

** org-roam
#+begin_src emacs-lisp
(use-package org-roam
  :ensure t
  :hook (after-init . org-roam-setup)
  :diminish
  :init (setq org-roam-v2-ack t)
  :config
  (setq org-roam-directory "~/org/roam"
        emacsql-sqlite3-executable (executable-find "sqlite3")
        org-roam-capture-templates
        '(("d" "default" plain "%?" :if-new
           (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n")
           :unnarrowed t
           :immediate-finish t)))

  (defhydra dkellner/org-roam (:exit t)
    "org-roam"
    ("f" #'org-roam-node-find "find")
    ("i" #'org-roam-node-insert "insert")
    ("b" #'org-roam-buffer-toggle "backlinks"))

  (bind-key* "C-c r" #'dkellner/org-roam/body))
#+end_src

** org-tree-slide
#+begin_src emacs-lisp
(use-package org-tree-slide
  :ensure t)
#+end_src

** Dirvish
#+begin_src emacs-lisp
(use-package dirvish
  :ensure t
  :init
  (dirvish-override-dired-mode)
  :config
  (setq dirvish-attributes '(all-the-icons file-size collapse
                             file-time subtree-state vc-state))
  :bind (("C-x C-d" . dired)
         :map dirvish-mode-map
         ("TAB" . dirvish-subtree-toggle)))
#+end_src

** Embark
#+begin_src emacs-lisp
(use-package embark
  :ensure t
  :bind ("C-." . embark-act))

(use-package embark-consult
  :ensure t)
#+end_src

** Eat
#+begin_src emacs-lisp
(use-package eat
  :ensure t
  :config
  (setq eshell-visual-commands nil)
  (add-hook 'eshell-load-hook #'eat-eshell-mode))
#+end_src

** csv-mode
#+begin_src emacs-lisp
(use-package csv-mode
  :ensure t)
#+end_src

** deadgrep + wgrep
#+begin_src emacs-lisp
(use-package deadgrep
  :ensure t)

(use-package wgrep-deadgrep
  :ensure t)
#+end_src

* Meta
** Private configuration
#+begin_src emacs-lisp
(load "~/.emacs.d/private.el")
#+end_src
